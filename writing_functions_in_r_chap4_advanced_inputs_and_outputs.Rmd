---
title: "Writing Functions in R (Chapter 4)"
subtitle: "Advanced Inputs and Outputs"
author: "Seun Odeyemi"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: united
    highlight: tango
    toc: true
    toc_depth: 4
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(error = TRUE, 
                      collapse = TRUE, 
                      comment = "#>")
library(styler)
library(lintr)
library(purrr)
```

# Dealing with failure

In this chapter we'll start with tools for dealing with errors and then you'll learn about variations on the types of inputs and outputs. One downside of map functions compared to for loops is that if one of the iteration fails, the whole thing fails. You don't see any of the result up to that point. That can make using map functions quite frustrating. One way the `purrr` package helps us to deal with this issue is using the `safely()` function.  

```{r safely_in_purrr}
safe_log <- safely(log)
```

`safely()` is like an adverb: it takes a function and returns a modified function that never throws an error. When we apply safely to log, the result is a new function. It's called just like `log` but the return value is now a little different. Instead of returning a result or throw an error, a safe function always returns a list with two components: results and error. If the function worked, then result contains the result and the error is NULL otherwise, the result is NULL and the error component contains the error message. 

```{r}
safe_log(10)
safe_log("a")
```

In the example above, `log(10)` will work without error so `safe_log(10)` returns a list with the result element containing the expected value i.e. the `log(10)` and the error value is NULL. log("a") will normally produce an error so the result element is NULL and the error element contains the error message. This structure is not always the most convenient in practice so in the exercises you'll about the helpful transpose functions. 

There are other purrr functions that work like `safely()`:

* `possibly()` always succeeds, but instead of returning a list you give it a default value to return when there is an error. 

* `quietly()` captures printed output, messages, and warnings instead of capturing errors. 

# Practice I

1. Creating a safe function

`safely()` is an adverb; it takes a verb and modifies it. That is, it takes a function as an argument and it returns a function as its output. The function that is returned is modified so it never throws an error (and never stops the rest of your computation!).

Instead, it always returns a list with two elements:

1. result is the original result. If there was an error, this will be NULL.
2. error is an error object. If the operation was successful this will be NULL.

Let's try to make the `readLines()` function safe.

```{r readLines}
# Create safe_readLines() by passing readLines() to safely()
safe_readLines <- safely(readLines)

# Call safe_readLines() on "http://example.org"
example_lines <- safe_readLines("http://example.org")
example_lines

# Call safe_readLines() on "http://asdfasdasdkfjlda"
nonsense_lines <- safe_readLines("http://asdfasdasdkfjlda")
nonsense_lines
```

2. Using map safely

One feature of safely() is that it plays nicely with the `map()` functions. Consider this list containing the two URLs from the last exercise, plus one additional URL to make things more interesting:

```{r}
urls <- list(
  example = "http://example.org",
  rproj = "https://www.r-project.org",
  asdf = "http://asdfasdasdkfjlda"
)
```

We are interested in quickly downloading the HTML files at each URL. You might try:

```{r}
map(urls, readLines) # returns an error

# Use the safe_readLines() function with map(): html
html <- map(urls, safe_readLines)

# Call str() on html
str(html)

# Extract the result from one of the successful elements
html$example[["result"]]

# Extract the error from the element that was unsuccessful
html$asdf[["error"]]
```

```{r}

```

