---
title: "Data Visualization with ggplot2 (Part 3)"
subtitle: "Statistical Plots (Chapter 1)"
author: "Seun Odeyemi"
date: "`r Sys.Date()`"
output:
  # pdf_document:
  #   df_print: kable
  #   toc: yes
  #   toc_depth: 4
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: yes
    toc_depth: 4
  bibliography: dataviz.bib
---


```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE, comment = "#>")
```

## Load Libraries

```{r load libraries, include=TRUE, message=FALSE}
library(readr)
library(dplyr)
library(ggplot2)
# library(ggplot2movies)
library(tidyr)
library(skimr)
library(knitr)
library(kableExtra)
library(RColorBrewer)
library(grid)
library(ggthemes)
library(forcats)
library(GGally)
library(here)
```

## Introduction

Welcome to data visualization with ggplot2 (part 3). This course assumes you are familiar with the concepts and functions of data visualization introduced in the first two courses, part 1 & 2. Those courses should have give you a pretty good idea about what good data visualization is and how to achieve it. Since, this is an advanced course we are to dig a bit deeper into some more advanced ggplot2 functions. Before we get to that we will cap off the material we began in the first two courses by rounding out your knowledge with some niche topics. We will begin by exploring two kinds of specialized plots. In **Chapter 1**, we will consider the first type of specialized plots, those suited for a data savvy audience. These are statistical plots you wouldn't normally see in the popular press like *boxplots* and *density plots*. Plus, we will consider how to combine several variables. In **Chapter 2**, we will move on to the second type of specialized plots, those that are suited for a specific data type. We will begin by putting some fundamental concepts of working with large datasets into perspective. And then we will see some specific cases like **kenuri plots** (?), *networks*, and *diagnostic plots*. 

This topic will continue into **Chapter 3** where we'll consider two main classes of maps: *coral plots* and *carthographic maps*. Finally, we'll see many concepts come together with the last type of specialized plot, **animations**---it's likely we'll cover `gganimate` in this section---which adds video frames as another mapping aesthetic. Depending on your area of expertise you may find out you seldom have a need to use this specialized plot types, but it is still useful to know what's possible within the ggplot2 framework. In **Chapter 4** we are going to get under the hood by digging into the internals of ggplot2 objects. For this we'll begin by looking at the basics of the `grid` package on which ggplot2 is built. The next step is to begin manipulating graphical objects that we made with ggplot2 and look at more efficient ways of doing that with some built-in functions in ggplot2 such as `ggplot_build()`. In the last part, we'll make use of a useful accessory package called `gridExtra`. In **Chapter 5**, we will bring our series on ggplot2 to a close with two case studies. In the first case study we'll look at a feature that was introduced in ggplot2 (2.0), _*extensions*_. We will understand how to build a new geom or stat_function from scratch. This will allow us to use ggplot2 to create exactly the statistics and visualizations we want in a more straightforward manner. In the second case study we are going to reproduce a classic plot by **Edward Tufte** using data familiar to everyone, the weather. Using ggplot2, we will create a unique plot drawing on what we've learned over all three courses. To cap all off, we are going to combine our Tufte weather plot with ggplot2 extensions and turn our unique plot type into a flexible, efficient, and reproducible plot type that we can use with any dataset of the appropriate type. 

## Refresher (1)

As a refresher to statistical plots, let's build a scatter plot with an additional statistic layer.

A dataset called movies_small is coded in your workspace. It is a random sample of 1000 observations from the larger movies dataset, that's inside the ggplot2movies package. The dataset contains information on movies from IMDB. The variable votes is the number of IMDB users who have rated a movie and the rating (converted into a categorical variable) is the average rating for the movie.

```{r refresher_1, fig.height=6, fig.width=6, fig.align='center'}
# Using the sample function to do a random sampling of a dataset
# library(ggplot2movies)
# set.seed(123)
# movies_small <- movies[sample(nrow(movies), 1000), ]
# movies_small$rating <- factor(round(movies_small$rating))

(movies_small <- readRDS(here("datasets/ch1_movies_small.RDS"))) %>% as_tibble()

# take a look at the variables in movies_small
glimpse(movies_small)

# Build a scatter plot with mean and 95% CI
ggplot(movies_small, aes(x = rating, y = votes)) +
  geom_point() +
  stat_summary(fun.data = "mean_cl_normal",
               geom = "crossbar",
               width = 0.2,
               col = "red") +
  scale_y_log10()
```

## Refresher (2)

The plot in the graphics device is a variation on an oft-seen `ggplot2` example using the `diamonds` dataset (containing information on several variables of over 50,000 diamonds).

Recall that there are a variety of `scale_` functions. Here, data are transformed or filtered first, after which the plot and associated statistics are computed. For example, scale_y_continuous(limits = c(100, 1000) will remove values outside that range.

Contrast this to `coord_cartesian()`, which computes the statistics before plotting. That means that the plot and summary statistics are performed on the raw data. That's why we say that `coord_cartesian(c(100, 1000))` "zooms in" a plot. This was discussed in the chapter on coordinates in course 2.

Here we're going to expand on this and introduce `scale_x_log10()` and `scale_y_log10()` which perform *log10* transformations, and `coord_equal()`, which sets an aspect ratio of 1 (`coord_fixed()` is also an option).

Your task is to reproduce the plot in the viewer. Before you do this, it might be a good idea to explore diamonds in the console if you are not familiar with it.

```{r refresher_2, fig.height=6, fig.width=6, fig.align='center'}
# Reproduce the plot
ggplot(diamonds, aes(x = carat, y = price, col = color)) +
  geom_point(alpha = 0.5, size = 0.5, shape = 16) +
  scale_x_log10(expression(log[10](Carat)), limits = c(0.1,10)) +
  scale_y_log10(expression(log[10](Price)), limits = c(100,100000)) +
  scale_color_brewer(palette = "YlOrRd") +
  coord_equal() +
  theme_classic()
```

Good job! This is a nice way of transforming data and then plotting it in one command.

## Refresher (3)

```{r refresher_3, fig.height=6, fig.width=6, fig.align='center'}
# Add smooth layer and facet the plot
ggplot(diamonds, aes(x = carat, y = price, col = color)) +
  stat_smooth(method = "lm") +
  # geom_point(alpha = 0.5, size = 0.5, shape = 16) +
  scale_x_log10(expression(log[10](Carat)), limits = c(0.1,10)) +
  scale_y_log10(expression(log[10](Price)), limits = c(100,100000)) +
  scale_color_brewer(palette = "YlOrRd") +
  coord_equal() +
  theme_classic()
```

Good job! Parametric and non-parametric linear models are common in scatter plots.

## Box Plots

In this section we'll take a look at our first class of specialized plots---or statistical plots---actually all the plots we've made so far can be called statistical plots since data visualization _*operates at the intersection of design and statistics*_. However, in contrast to the plots we've seen previously, these are more well-suited to an academic audience. We are going to look at two very common plot types for visualizing the distribution of continuous data:

* Box plots
* Density plots

We'll return to boxplots in the case study when we develop a new statistics layer to produce a two-dimensional box plot. 

Boxplots were originally described by John Tukey in his 1977 classic text, *_Exploratory Data Analysis_* [see @tukey_exploratory_2020, pp. 25, 40]. So actually, they are not that old. Tukey described them as a way to visualize the so-called, *_Five Number Summary_*: Lower Extreme (or minimum), Lower Hinge ($1^{st}$ Quartile or Q1 or 25 Percentile), Median (or Q2), Upper Hinger ($3^{rd}$ Quartile or Q3 or 75 Percentile), Upper Extreme (or maximum). The **Inter-Quartile Range** (IQR) is Q3 - Q1, which is the same thing as the Median of the distribution. The Median is a measurement of location and spread. We can think of the boxplot as a **robust**^[robust statistics are measures on which extreme observations have little effect.] equivalent of the mean and the standard deviation. 

|         | **robust**   | **non-robust**|
|:--------|:-------------|:-------------|
|center   |    median    | mean         |
|spread   |IQR           |SR, range     |

Table 1: median & IQR only depend on the midpoint of the distribution and the values of the end point are irrelevant to its calculation, whereas mean & SD are affected. Hence, mean & SD are usually good for symmetric or normal distributions. 

The Five Number Summary gives us a better impression of the distribution of the dataset. We get an impression of the skew because each of the four segments---the two outer whiskers and the two parts of the inner bar---reflect 25% of the data. There is a further subtle point to boxplots: The ability to show extreme values as distinct features. An extreme value is defined as **falling outside the range of 1.5 times the IQR, either below Q1 or above Q3**. This is called the **fence**^[Note: The fence can be adjusted and the default depends on the software.]. To understand how the fence works, we'll use the same dataset we've working so far, but we'll pull the maximum value further and further away from its starting position causing the dataset to slowly become positively skewed. Any value that surpasses the fence will be drawn as a dot, the boxplot is also updated; the whisker is drawn up to the highest elevation **_within_** the fence. It doesn't matter how many values are outside the fence or how faraway they are, they all get represented as dots. The whiskers never extend beyond the fence. If you are not clear about how the plot is drawn, you can actually get the wrong view of the data distribution. Many people who commonly use or encounter boxplots are not aware that the midline is the median and not the mean. Nor are they aware that the dots represents extreme values that are part of the data, and therefore should not be disregarded. So use these plots with caution. 

### Transformations

In this exercise you'll return to the first plotting exercise and see how box plots compare to dot plots for representing high-density data.

Box plots are very useful, but they don't solve all your problems all the time, for example, when your data are heavily skewed, you will still need to transform it. You'll see that here, using the movies_small dataset, a subset of 10,000 observations of `ggplot2movies::movies`

```{r transformations, fig.height=6, fig.width=6, fig.align='center'}
# movies_small is available

# Add a boxplot geom
d <- ggplot(movies_small, aes(x = rating, y = votes)) +
  geom_point() +
  geom_boxplot() +
  stat_summary(fun.data = "mean_cl_normal",
               geom = "crossbar",
               width = 0.2,
               col = "red")

# Untransformed plot
d

# Transform the scale
d + scale_y_log10() # the transformation happens before calculating the statistics

# Transform the coordinates
d + coord_trans(y = "log10") # the transformation happens after calculating the statistics
```

Good job! Notice how different the normal distribution estimation (red boxes) and boxplots (less prone to outliers) are.

### Cut it up!

If you only have continuous variables, you can convert them into ordinal variables using any of the following functions:

* `cut_interval(x, n)` makes n groups from vector x with equal range.
* `cut_number(x, n)` makes n groups from vector x with (approximately) equal numbers of observations.
* `cut_width(x, width)` makes groups of width width from vector x.

This is useful when you want to summarize a complex scatter plot like the one shown in the viewer. By applying these functions to the carat variable and mapping that onto the group aesthetic, you can convert the scatter plot in the viewer into a series of box plots on the fly.

```{r cut_it_up, fig.height=6, fig.width=6, fig.align='center'}
# Plot object p
p <- ggplot(diamonds, aes(x = carat, y = price))

# Use cut_interval
p + geom_boxplot(aes(group = cut_interval(carat, n = 10)))

# Use cut_number
p + geom_boxplot(aes(group = cut_number(carat, n = 10)))

# Use cut_width
p + geom_boxplot(aes(group = cut_width(carat, width = 0.25)))
```

Good job! Going from a continuous to a categorical variable reduces the amount of information, but sometimes that helps us understand the data.

### Understanding quartiles

Be aware that there are many ways to calculate the IQR, short for inter-quartile range (that is $Q3−Q1$). These are defined in the help pages for the `quantile()` function:

> ?quantile

To explore the differences in these types, a function called `plot_quart()` is available, that takes one argument: an integer specifying the number of values. Using `rnorm()` a vector of values will be generated and the quartiles will be calculated using nine different methods. Run the command in the console on the right using different values (for example 4, 10, 50, 100).

What can you say about how the quartiles and the IQR are calculated?

```{r plot_quart_function}
plot_quart <- function(n) {
  set.seed(123)
  playData <- data.frame(raw.values = rnorm(n, 1, 6))

  quan.summary <- data.frame(t(sapply(1:9, function(x) quantile(playData$raw.values, type = x))))
  names(quan.summary) <- c("Min", "Q1", "Median", "Q3", "Max")
  quan.summary$Type <- as.factor(1:9)

  library(reshape2)
  quan.summary <- melt(quan.summary, id = "Type")
  quan.summary <- list(quartiles = quan.summary, values = playData)

  ggplot(quan.summary$quartiles, aes(x = Type, y = value, col = variable)) +
    geom_point() +
    geom_rug(data = quan.summary$values, aes(y = raw.values), sides = "l", inherit.aes = F)
}
```

```{r use_plot_quart}
plot_quart(4)

plot_quart(10)

plot_quart(50)

plot_quart(100)
```

**The IQR becomes more consistent across methods as the sample size increases**. Yes, the subtle difference between methods is not as pronounced when the sample size is large. In any case, you are likely to encounter spurious artefacts when drawing box plots with small sample sizes.