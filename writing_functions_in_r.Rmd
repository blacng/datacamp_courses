---
title: "Writing Functions in R"
author: "Seun Odeyemi"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: united
    highlight: tango
    toc: true
    toc_depth: 4
    toc_float: true
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE, comment = "#>")
```

## A Quick Refresher

### Writing a Function

The function template is a useful way to writing a function:

```r 
my fun <- function (arg1, arg2) {
        # body
}
```

`my_fun` is the variable that you want to assign your function to, `arg1` and `arg2` are arguments to the function. The template has two arguments, but you can specify any number of arguments, each separated by a comma. You then replace `# body` with the R code that your function will execute, referring to the inputs by the argument names you specified.

```{r write_fx}
my_fun <- function(arg1, arg2) {
  # body
}

ratio <- function(x, y) {
  x / y
}

ratio(3, 4)

# Get some metadata of the function ratio
formals(ratio)
body(ratio)
environment(ratio)
```

The output of the `formals` shows us that the function, `ratio` is defined with two arguments: x and y. The `body` of the function is `x/y` and the `environment` is `global`.  

### Arguments

How did you call your function `ratio()` in the previous exercise? Do you remember the two ways to specify the arguments? (If you have forgotten it might be useful to review the video from Intermediate R)

You probably either did `ratio(3, 4)`, which relies on matching by *position*, or `ratio(x = 3, y = 4)`, which relies on matching by *name*.

For functions you and others use often, it's okay to use positional matching for the first one or two arguments. These are usually the data to be computed on. Good examples are the x argument to the summary functions (`mean()`, `sd()`, etc.) and the `x` and `y` arguments to plotting functions.

However, beyond the first couple of arguments __you should always use matching by name__. It makes your code much easier for you and others to read. This is particularly important if the argument is optional, because it has a default. When overriding a default value, it's good practice to use the name.

Notice that when you call a function, you should place a space around `=` in function calls, and always put a space after a comma, not before (just like in regular English). Using whitespace makes it easier to skim the function for the important components.

```{r rewrite_fx_call}
# Rewrite the call to follow best practices
mean(x = c(1:9, NA), trim = 0.1, na.rm = TRUE)
```


### Scoping in R

Scoping describes how R looks up values by name. If I assign the value `10` to a variable `x` (as shown below), scoping describes the process R uses to find the value 10. 

```{r understanding_scoping_in_r}
x <- 10

f <- function() {
  x <- 1
  y <- 2
  c(x, y)
}

f()
```

When the above function (`f`) is called, the function begins execution in a new working environment. In this new environment x and y are defined, they are then put in a vector and returned. Unsurprisingly, the returned value is the vector 1, 2. 

> If a variable referred to inside a function does not exist in the function's current working environment, R will look one level up.

```{r scoping_1}
x <- 2
# rm(x)

g <- function() {
  y <- 1
  c(x, y)
}

g()
```

> Scoping describes where, not when, to look for a value. This means the returned value of a function could depend on when you call it. 
 
```{r scoping_2}
f <- function() x
x <- 15
f()

x <- 20
f()
```

* The behavior shown above reflects an undesirable behavior of a function. This is why when you create a function **make sure your function does not depend on variables other than the arguments**. We'll more about this in Chapter 5 on robust functions. 

> Lookup by name works exactly the same when the name refers to a function. 

```{r lookup_fx_by_name}
l <- function(x) x + 1
m <- function() {
  l <- function(x) x * 2
  l(10)
}
m()
```

When you the function `m` is called and it reaches the line call `l` with the value, **10**, R uses the `l` function defined locally i.e. `x * 2` and returns **20**. 

If it is obvious you are using a name like a function, R ignores the function object when it looks it up. Here is a tricky example. 

```{r tricky_fx_example}
c <- 3
c(c = c)
```

`c` is being used in 3 ways:

1. As a function and R correctly finds the `c` function and combines values into a vector. 
2. `c` is being used as a name. 
3. `c` refers to a value, which R looks up and finds it's 3. 

> Every time a function is called it gets a clean working environment. This means different calls to the same function are completely independent. 

```{r demo_of_fx_clean_envir}
j <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  print(a)
}
```

Regardless of how many times you call `j`, it will always return 1. Since, each time it is called the working environment is empty. `a` is created in this working environment, but the environment disappears as soon as `j` exits. 

```{r call_j}
j()

a
```

This also means any local variable created in the function are never available on the global.  environment. 

#### Summary

* When you call a function, a new environment is made for the function to do its work
* The new environment is populated with the argument values
* Objects are looked for first in this environment
* If they are not found, they are looked for in the environment that the function was created in

```yaml
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
```

## Functional Programming

Feel free to use the `knitr` infrastructure with dozens of tunable options in
your document.

```{r fig.width=6, fig.height=6, fig.align='center'}
set.seed(123)
n <- 1000
x1 <- matrix(rnorm(n), ncol = 2)
x2 <- matrix(rnorm(n, mean = 3, sd = 1.5), ncol = 2)
x <- rbind(x1, x2)
head(x)
smoothScatter(x, xlab = "x1", ylab = "x2")
```

You can include code snippets of languages other than R, but note that
the block header has no curly brackets around the language name.

```cpp
// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
    return x * 2;
}
```

You can also write math expressions, e.g. $Y = X\beta + \epsilon$,
footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(iris, 10))
```

## Advanced Input and Output

Please visit the [development page](http://github.com/yixuan/prettydoc/) of the 
`prettydoc` package for latest updates and news. Comments, bug reports and
pull requests are always welcome.

## Robust Functions
